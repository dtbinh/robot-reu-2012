# Antonella Wilby and Vivian Wehner

#!/usr/bin/env python
import roslib; roslib.load_manifest('irobot_mudd')
import rospy
import irobot_mudd
import cv_bridge
import cv
import sensor_msgs.msg as sm
from std_msgs.msg import String
from irobot_mudd.srv import *
from irobot_mudd.msg import *
#import Navigator
#import HandleData
import Interface

#D = Navigator.get_data_instance()

####################### CALLBACK FUNCTIONS #########################

def onMouse(event, x, y, flags, param):
    """ the method called when the mouse is clicked """
    
    if event==cv.CV_EVENT_LBUTTONDOWN:  #Clicked the left button
        print "x, y are", x, y
        (b,g,r) = D.image[y,x]
        print "r,g,b is", int(r), int(g), int(b)
        (h,s,v) = D.hsv[y,x]
        print "h,s,v is", int(h), int(s), int(v)
        D.down_coord = (x,y)
        D.mouse_down = True
        
    elif event==cv.CV_EVENT_LBUTTONUP:  #Let go of the left button
        print "x, y are", x, y
        (b,g,r) = D.image[y,x]
        print "r,g,b is", int(r), int(g), int(b)
        (h,s,v)  = D.hsv[y,x]
        print "h,s,v is", int(h), int(s), int(v)
        D.up_coord = (x,y)
        D.mouse_down = False

        if D.mode == "clear":
            D.sections = []
        else:                           #Start, add, or subtract -- put lower coordinates first
            x0 = D.down_coord[0]
            y0 = D.down_coord[1]
            x1 = D.up_coord[0]
            y1 = D.up_coord[1]

            if x0 > x1:
                x0, x1 = x1, x0
            if y0 > y1:
                y0, y1 = y1, y0
            
            if D.mode == "start":
                D.sections = []
            mode_dict = {"start":'a', "add":'a', "subtract":'s'}
            D.sections.append([mode_dict[D.mode], (x0, y0), (x1, y1)])
            process_section()


    elif event == cv.CV_EVENT_RBUTTONDOWN:                      #Right click
        D.target_coord = (x, y)
        target_coord()


    elif D.mouse_down and event==cv.CV_EVENT_MOUSEMOVE:      #Mouse just moved
        D.up_coord = (x,y)



def check_key_press(D, key_press):
    """ this handler is called when a real key press has been
        detected, and updates everything appropriately
    """
    
    D.last_key_pressed = key_press

    # So we know what we'll do if we get one of these key presses
    key_dictionary = {ord('t'): "threshed_image",\
                      ord('r'): "red",\
                      ord('g'): "green",\
                      ord('b'): "blue", \
                      ord('H'): "hue", \
                      ord('a'): "sat", \
                      ord('v'): "val"}

    if key_press == ord('q') or key_press == 27: # if a 'q' or ESC was pressed
        print "quitting"
        rospy.signal_shutdown( "Quit requested from keyboard" )
        
    elif key_press == ord('h'):
        print " Keyboard Command Menu"
        print " =============================="
        print " ESC/q: quit"
        print " h    : help menu"
        print " s    : save thresholds to file"
        print " l    : load thresholds from file"
        print " p    : mousedrags will no longer set thresholds, kept values will be cleared"
        print " i    : mousedrag will set thresholds to area within drag, \n" + \
              "        resets on new click or drag"
        print " j    : mousedrags will remove the area under consideration, \n" + \
              "        must have set an area in 'i' mode first"
        print " k    : mousedrags will add the area under consideration, \n" + \
              "        must have set an area in 'i' mode first"
        print " t    : show total threshold image in threshold window"
        print " r    : show red image in threshold window"
        print " g    : show green image in threshold window"
        print " b    : show blue image in threshold window"
        print " H    : show hue image in threshold window"
        print " a    : show saturation image in threshold window"
        print " v    : show value image in threshold window"


    #Save thresholds to file
    elif key_press == ord('s'):
        fileName = raw_input('Please enter the name of a color: ')
        fileName += "_thresholds.txt"
        writeFile = open(fileName, "w")         #open file for writing
        print >> writeFile, D.thresholds
        writeFile.close()


    #Load thresholds from file    
    elif key_press == ord('l'):
        whichFile = raw_input('Please enter the name of a color: ')
        whichFile += "_thresholds.txt"
        readFile = open(whichFile, "r")        #open file for reading
        data = readFile.read()
        D.thresholds = eval(data)
        readFile.close()

        #Reset threshold sliders
        for thresh in ['red', 'blue', 'green', 'hue', 'sat', 'val']:
            cv.SetTrackbarPos('low_' + thresh, 'Sliders', D['thresholds']['low_'+thresh])
            cv.SetTrackbarPos('high_' + thresh, 'Sliders', D['thresholds']['high_'+thresh])


    #Area selection controls
    elif key_press == ord('u'):
        D.mode = "clear"
        D.sections = []

    elif key_press == ord('i'):
        D.mode = "start"

    elif key_press == ord('j'):
        if len(D.sections) > 0:
            D.mode = "subtract"
        else:
            print "Cannot switch modes, need a starting area first. Press 'i' " + \
                "to select a starting area."

    elif key_press == ord('k'):
        if len(D.sections) > 0:
            D.mode = "add"
        else:
            print "Cannot switch modes, need a starting area first. Press 'i' " + \
                "to select a starting area."

    elif key_press == ord('f') or key_press == 82:
        state = "machine"
        state_start()


    #Robot keyboard driving controls
    elif key_press == 82:
	state = "machine"
	tank(100,100)

    elif key_press == 84:
        state = "machine"
        tank(-100,-100)

    elif key_press == 81:
        state = "machine"
        tank(0, 100)

    elif key_press == 83:
        state = "machine"
        tank(100, 0)

    elif key_press == 32:
        state = "machine"
        state_stop()
            
    elif key_press in key_dictionary.keys(): # If we said what the key_press maps to already
        D.current_threshold = key_dictionary[key_press]



##################### END CALLBACK FUNCTIONS #######################


